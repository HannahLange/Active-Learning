// Ausf√ºhren: povray settings minimal.pov
// povray "settings[high]" minimal.pov
// povray settings +W100 minimal.pov

#version 3.7;
// Einbinden von Bibliotheken
#include "colors.inc"
#include "shapes.inc"
#include "transforms.inc"
#include "functions.inc"
#include "textures.inc"
include "metals.inc"  



// Globale Variablen, auch mit ifdef, bool (on,off)
#declare Use_FocalBlur=off;  
#declare TimeEv = on;
// Declare variables
#ifndef (Background_Finish)
	#declare Background_Finish = finish{ambient 0.2 diffuse 0.8 brilliance 1.0}
#end 




// Global Settings
global_settings { // Beleuchtung global anpassen
	//assumed_gamma 1.1
	//ambient_light <0.0,0.0,0.5>
	//ambient_light 0.1
}   


// Standardwerte, falls nicht von Objekt √ºberschrieben
#default{finish{ambient 0.0				// Helligkeit aus indirekter Beleuchtung
				diffuse 0.1			// Helligkeit aus direkter Beleuchtung
				phong 0.0 				// Glanzlichter
				specular 0.05			// fl√§chiger Schimmer
				reflection 0.0 		// Helligkeit aus Spiegelung
				brilliance 2.0		// Abfall der Helligkeit abh√§ngig vom Einfallswinkel
				//crand 0.3 				// K√∂rnigkeit
				}}

background{color White}



// Kamera: Position, Ausrichtung, Zoom, ...
#declare cam_r = 200;
#declare cam_phi = 0;
#declare cam_theta = 0;
#declare cam_angle = 1.5;
#declare cam_sky = <0, 0, 1>;
#declare cam_rot = <0, 0, 0>;
#declare cam_right = <-5/4, 0, 0>;
#declare cam_loc = <cam_r*sin(cam_theta)*cos(cam_phi), cam_r*sin(cam_theta)*sin(cam_phi), cam_r*cos(cam_theta)>;
camera{
	perspective	// Projektion
	location cam_loc	// Position
	angle cam_angle		// Winkel (Lochkamera)
	rotate cam_rot		// Rotation
	sky cam_sky				// Oben
	right cam_right		// Rechts (standardm√§√üig linksh√§ndiges Koordinatensystem)
	look_at -cam_loc	// Ausrichtung der Kamera
	#if (Use_FocalBlur) // Tiefensch√§rfe (sehr Rechenintensiv!)
		focal_point  <0, 0, 0>
		aperture 2
		blur_samples 512
		confidence 0.95
		variance 1./4096
  #end
}






// Lichtquellen (mindestens eine, Punktlichter, Fl‰chenlichter, ...)
#declare light_r = 200;
#declare light_phi = 0;
#declare light_theta = 0;
#declare light_color = <1, 1, 1>;

#declare light_loc = <light_r*sin(light_theta)*cos(light_phi), light_r*sin(light_theta)*sin(light_phi), light_r*cos(light_theta)>;
light_source{
	light_loc
	color rgb light_color
	area_light <10, 0, 0>, <0, 0, 01>, 8, 8 // Fl√§chige Lichtquelle f√ºr weiche Schatten
}


#declare light_loc = <cam_r*sin(cam_theta)*cos(cam_phi), cam_r*sin(cam_theta)*sin(cam_phi), cam_r*cos(cam_theta)>;
light_source{
	light_loc
	color rgb light_color
}  

light_source
{
  <-2, -1, 19>
  color White*1.5 // White*0.8 
  area_light <1,0,0>*4.5, <-0,1,0>*4.5, 3, 3
  jitter
  spotlight
  radius 3.2
  falloff 13.2
   tightness 10
  point_at <0, 0, 0>
}


// Eigene Macros (Funktionen)----------------------------------------------- 
#macro Atom(pos)
object{
	    sphere{pos, 0.14}
	    texture{
		    pigment{rgbt <0,0,1>}
		    finish{brilliance 0.1
		           reflection 0
		           phong 0.1} }
	    } 
	  
#end
     
     
  


#macro AtomsCurve(tau,rad)
    (<cos(-tau), sin(-tau),0> * rad)
#end

#macro PlotAtomsCurve(rad)
union{
    #local LineRadius = 0.014;
    #local tau0 = 0.0*pi;
    #local tau1 = tau0-2*pi-0.05*pi;
    
    #local tau = tau0;
    object{sphere{ AtomsCurve(tau, rad), LineRadius }  
           texture{pigment{color rgbt <0.3,1,0.,0.3,1>} finish{diffuse 0 ambient 0.2 specular 0}}}
    #while( tau > tau1 )
        union{cylinder{ AtomsCurve(tau, rad), AtomsCurve(tau+0.05, rad), LineRadius }
        sphere{ AtomsCurve(tau+0.05, rad), LineRadius } 
        texture{pigment{color rgbt <0.3,1,0.,1+tau/(2*pi)*0.9+0.1>} finish{diffuse 0 ambient 0.2 specular 0}}}
        
        #local tau = tau - 0.05;
    #end 
    #declare tau=tau0-1.*pi;
    object{cone{ AtomsCurve(tau+0.4, rad), LineRadius*6, AtomsCurve(tau-0.15, rad), 0 } 
           texture{pigment{color rgbt <0.3,1,0.>} finish{diffuse 0 ambient 0.2 specular 0}}}
    }
#end 

#macro AtomOnCurve(central_pos, atom_phase, total_phase, r,show_circle)
    union{
        #if (show_circle)
            PlotAtomsCurve(r) 
        #end
        Atom(AtomsCurve(atom_phase, r))
        rotate total_phase*z
        translate central_pos+0.1*z}

#end 




#macro AtomsOnCurve_Lattice(lattice_pos, num_atoms, TimeEv) 
    #declare Rnd_1 = seed (1153);
    #for(n, 0, num_atoms-1)  
        #declare total_phase = rand(Rnd_1); 
        #if (TimeEv)
            AtomOnCurve(lattice_pos[n],0*pi,(total_phase*360-5*clock),0.25,off)
        #end
        AtomOnCurve(lattice_pos[n],0*pi,total_phase*360,0.25,on)
    #end
#end


#macro Transformation(Scale,zRot,Position)
	scale Scale 
	rotate <0,0,zRot> // um z-Achse drehen
	translate Position
#end   

 
#macro extend_Lattice(lattice_pos, extensions)  
    #for (n,-1,1,1)
    object{
	    sphere_sweep{linear_spline 2, 
	    <n,1*extensions,0>,0.03,
	     <n,-1*extensions,0>,0.03}
	    texture{ pigment{color rgbt <1,1,1, 0.7>}
	    finish{reflection 0
	           brilliance 0
	           ambient 0.1
	           diffuse 0.1
	           phong 0
	           specular 0
	           metallic 0}}
    translate -0.01*z} 
    object{
	    sphere_sweep{linear_spline 2, 
	    <1*extensions,n,0>,0.03,
	     <-1*extensions,n,0>,0.03}
	    texture{ pigment{color rgbt <1,1,1, 0.7>}
	    finish {reflection 0
	            brilliance 0
	            ambient 0.1
	            diffuse 0.1
	            phong 0
	            specular 0
	            metallic 0}}
    translate 0.011*z}
    #end 
#end






//--------------------------------------------------------------------------------------

#declare atomPos_size = 9; 
#declare lattice_a = 1;
#declare lattice_pos = array[atomPos_size]{
    < +0.0, +0.0, +0.0 > * lattice_a,
    < +1.0, +0.0, +0.0 > * lattice_a,
    < -1.0, +0.0, +0.0 > * lattice_a,
    < +0.0, +1.0, +0.0 > * lattice_a, 
    < +0.0, -1.0, +0.0 > * lattice_a,
    < +1.0, +1.0, +0.0 > * lattice_a,
    < -1.0, +1.0, +0.0 > * lattice_a,
    < +1.0, -1.0, +0.0 > * lattice_a, 
    < -1.0, -1.0, +0 > * lattice_a}; 

union{ 
    AtomsOnCurve_Lattice(lattice_pos, atomPos_size, TimeEv) 
    extend_Lattice(lattice_pos,1.3)
    Transformation(1.3,0,<0,0,0>)
}
  
  
